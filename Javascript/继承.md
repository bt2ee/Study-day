## ES5 继承

#### 原型链继承

**基本思想**

将父类的实例作为子类的原型

```js
function SuperType() {
  this.name = 'SuperType'
}
SuperType.prototype.sayName = function() {
  return this.name
}

function SubType() {
  this.subName = 'SubType'
}

SubType.prototype = new SuperType()

SubType.prototype.saySubName = function() {
  return this.subName
}

let instance = new SubType()

console.log(instance, '===instance')
console.log(instance.prototype, '===instance')

instance instanceof SuperType
instance instanceof SubType

SubType instanceof SuperType; // false
SubType.prototype instanceof SuperType; // true
```

**特点**

利用原型，让一个引用类型继承另一个引用类型

**优点**

继承了父类的模板，又继承了父类的原型对象

**缺点**

  - 可以在子类构造函数中，为子类实例增加实例属性。如果要新增原型属性和方法，则必须放在 `SubType.prototype = new SuperType('SubType');` 这样的语句之后执行。
  - 无法实现多继承
  - 来自原型对象的所有属性被所有实例共享
  - 创建子类实例时，无法向父类构造函数传参，或者说是，没办法在不影响所有对象实例的情况下，向超类的构造函数传递参数

## ES6 继承
